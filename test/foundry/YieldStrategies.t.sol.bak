// SPDX-License-Identifier: BSD-3-Clause
pragma solidity ^0.8.24;

/**
 * @title Yield Strategies Comprehensive Test Suite
 * @notice Tests for Aave V3, Yearn V3, Compound, Euler, Fluid, and Pendle strategies
 * @dev Covers:
 *      - IYieldStrategy interface compliance
 *      - Deposit/withdraw operations
 *      - Harvest functionality
 *      - APY calculations
 *      - Emergency withdrawals
 *      - Access control
 *      - Edge cases and fuzz testing
 */

import "forge-std/Test.sol";
import "forge-std/console.sol";

import {AaveV3SupplyStrategy, AaveV3LeverageStrategy, IPool, IAToken, IRewardsController, IPriceOracle, DataTypes} from "../../contracts/bridge/yield/strategies/AaveV3Strategy.sol";
import {IYieldStrategy} from "../../contracts/bridge/yield/IYieldStrategy.sol";

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";

// ═══════════════════════════════════════════════════════════════════════════════
// MOCK ERC20
// ═══════════════════════════════════════════════════════════════════════════════

contract MockERC20 is ERC20 {
    uint8 private _decimals;

    constructor(string memory name, string memory symbol, uint8 decimals_) ERC20(name, symbol) {
        _decimals = decimals_;
    }

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }

    function burn(address from, uint256 amount) external {
        _burn(from, amount);
    }

    function decimals() public view override returns (uint8) {
        return _decimals;
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// MOCK AAVE PROTOCOL
// ═══════════════════════════════════════════════════════════════════════════════

contract MockAToken is MockERC20 {
    address public immutable POOL;
    address public immutable UNDERLYING_ASSET_ADDRESS;
    uint256 public liquidityIndex = 1e27;

    constructor(address pool, address underlying) MockERC20("aToken", "aT", 18) {
        POOL = pool;
        UNDERLYING_ASSET_ADDRESS = underlying;
    }

    function scaledBalanceOf(address user) external view returns (uint256) {
        return (balanceOf(user) * 1e27) / liquidityIndex;
    }

    function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256) {
        return ((balanceOf(user) * 1e27) / liquidityIndex, (totalSupply() * 1e27) / liquidityIndex);
    }
}

contract MockAavePool is IPool {
    mapping(address => MockAToken) public aTokens;
    mapping(address => MockERC20) public debtTokens;
    mapping(address => DataTypes.ReserveData) public reserves;
    uint256 public supplyRate = 3e25; // 3% APY
    uint256 public borrowRate = 5e25; // 5% APY

    function setAToken(address asset, address aToken) external {
        aTokens[asset] = MockAToken(aToken);
        reserves[asset].currentLiquidityRate = uint128(supplyRate);
        reserves[asset].currentVariableBorrowRate = uint128(borrowRate);
        reserves[asset].aTokenAddress = aToken;
        reserves[asset].liquidityIndex = 1e27;
        reserves[asset].variableBorrowIndex = 1e27;
    }

    function setDebtToken(address asset, address debtToken) external {
        debtTokens[asset] = MockERC20(debtToken);
        reserves[asset].variableDebtTokenAddress = debtToken;
    }

    function supply(address asset, uint256 amount, address onBehalfOf, uint16) external override {
        IERC20(asset).transferFrom(msg.sender, address(this), amount);
        aTokens[asset].mint(onBehalfOf, amount);
    }

    function withdraw(address asset, uint256 amount, address to) external override returns (uint256) {
        if (amount == type(uint256).max) {
            amount = aTokens[asset].balanceOf(msg.sender);
        }
        aTokens[asset].burn(msg.sender, amount);
        IERC20(asset).transfer(to, amount);
        return amount;
    }

    function borrow(address asset, uint256 amount, uint256, uint16, address onBehalfOf) external override {
        IERC20(asset).transfer(msg.sender, amount);
        debtTokens[asset].mint(onBehalfOf, amount);
    }

    function repay(address asset, uint256 amount, uint256, address onBehalfOf) external override returns (uint256) {
        if (amount == type(uint256).max) {
            amount = debtTokens[asset].balanceOf(onBehalfOf);
        }
        IERC20(asset).transferFrom(msg.sender, address(this), amount);
        debtTokens[asset].burn(onBehalfOf, amount);
        return amount;
    }

    function setUserUseReserveAsCollateral(address, bool) external override {}
    
    function getUserAccountData(address user) external view override returns (
        uint256 totalCollateralBase,
        uint256 totalDebtBase,
        uint256 availableBorrowsBase,
        uint256 currentLiquidationThreshold,
        uint256 ltv,
        uint256 healthFactor
    ) {
        // Simplified for testing
        ltv = 8000;
        currentLiquidationThreshold = 8500;
        totalCollateralBase = 1000000e8;
        totalDebtBase = 0;
        availableBorrowsBase = 800000e8;
        healthFactor = type(uint256).max;
    }

    function getReserveData(address asset) external view override returns (DataTypes.ReserveData memory) {
        return reserves[asset];
    }

    function setUserEMode(uint8) external override {}
    function getUserEMode(address) external pure override returns (uint256) { return 0; }
}

contract MockRewardsController is IRewardsController {
    address[] public rewardTokens;
    mapping(address => uint256) public rewardAmounts;

    function setReward(address token, uint256 amount) external {
        rewardTokens.push(token);
        rewardAmounts[token] = amount;
    }

    function claimRewards(address[] calldata, uint256, address to, address reward) external override returns (uint256) {
        uint256 amount = rewardAmounts[reward];
        if (amount > 0) MockERC20(reward).mint(to, amount);
        return amount;
    }

    function claimAllRewards(address[] calldata, address to) external override returns (address[] memory, uint256[] memory) {
        uint256[] memory amounts = new uint256[](rewardTokens.length);
        for (uint i = 0; i < rewardTokens.length; i++) {
            amounts[i] = rewardAmounts[rewardTokens[i]];
            if (amounts[i] > 0) MockERC20(rewardTokens[i]).mint(to, amounts[i]);
        }
        return (rewardTokens, amounts);
    }

    function getUserRewards(address[] calldata, address, address reward) external view override returns (uint256) {
        return rewardAmounts[reward];
    }

    function getAllUserRewards(address[] calldata, address) external view override returns (address[] memory, uint256[] memory) {
        uint256[] memory amounts = new uint256[](rewardTokens.length);
        for (uint i = 0; i < rewardTokens.length; i++) {
            amounts[i] = rewardAmounts[rewardTokens[i]];
        }
        return (rewardTokens, amounts);
    }

    function getRewardsByAsset(address) external view override returns (address[] memory) {
        return rewardTokens;
    }
}

contract MockPriceOracle is IPriceOracle {
    mapping(address => uint256) public prices;

    function setAssetPrice(address asset, uint256 price) external {
        prices[asset] = price;
    }

    function getAssetPrice(address asset) external view override returns (uint256) {
        return prices[asset] == 0 ? 1e8 : prices[asset];
    }

    function getAssetsPrices(address[] calldata assets) external view override returns (uint256[] memory) {
        uint256[] memory result = new uint256[](assets.length);
        for (uint i = 0; i < assets.length; i++) {
            result[i] = prices[assets[i]] == 0 ? 1e8 : prices[assets[i]];
        }
        return result;
    }

    function getSourceOfAsset(address) external pure override returns (address) {
        return address(0);
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// AAVE V3 SUPPLY STRATEGY TESTS
// ═══════════════════════════════════════════════════════════════════════════════

contract AaveV3SupplyStrategyTest is Test {
    MockERC20 public underlying;
    MockAToken public aToken;
    MockAavePool public pool;
    MockRewardsController public rewards;
    MockPriceOracle public oracle;
    MockERC20 public rewardToken;
    AaveV3SupplyStrategy public strategy;

    address vault = address(0x1000);
    address user1 = address(0x2000);

    function setUp() public {
        underlying = new MockERC20("USDC", "USDC", 6);
        pool = new MockAavePool();
        aToken = new MockAToken(address(pool), address(underlying));
        rewards = new MockRewardsController();
        oracle = new MockPriceOracle();
        rewardToken = new MockERC20("AAVE", "AAVE", 18);

        pool.setAToken(address(underlying), address(aToken));
        pool.setDebtToken(address(underlying), address(new MockERC20("dUSDC", "dUSDC", 6)));
        rewards.setReward(address(rewardToken), 100e18);
        oracle.setAssetPrice(address(rewardToken), 100e8);

        strategy = new AaveV3SupplyStrategy(vault, address(pool), address(aToken), address(rewards), address(oracle));

        underlying.mint(vault, 1000000e6);
        underlying.mint(address(pool), 10000000e6);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DEPLOYMENT TESTS
    // ═══════════════════════════════════════════════════════════════════════

    function testDeployment() public {
        assertEq(strategy.vault(), vault);
        assertEq(address(strategy.pool()), address(pool));
        assertEq(address(strategy.aToken()), address(aToken));
        assertEq(strategy.underlyingAsset(), address(underlying));
        assertTrue(strategy.active());
        assertEq(strategy.name(), "Aave V3 Supply Strategy");
    }

    function testInterfaceCompliance() public {
        assertEq(strategy.asset(), address(underlying));
        assertTrue(strategy.isActive());
        assertEq(strategy.totalAssets(), 0);
        assertEq(strategy.totalDeposited(), 0);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DEPOSIT TESTS
    // ═══════════════════════════════════════════════════════════════════════

    function testDeposit() public {
        uint256 depositAmount = 10000e6;
        
        vm.startPrank(vault);
        underlying.approve(address(strategy), depositAmount);
        uint256 shares = strategy.deposit(depositAmount);

        assertEq(shares, depositAmount); // First deposit 1:1
        assertEq(strategy.totalShares(), shares);
        assertEq(strategy.shares(vault), shares);
        assertEq(strategy.totalDeposited(), depositAmount);
        assertGt(aToken.balanceOf(address(strategy)), 0);
        vm.stopPrank();
    }

    function testDepositZeroAmount() public {
        vm.startPrank(vault);
        vm.expectRevert(AaveV3SupplyStrategy.ZeroAmount.selector);
        strategy.deposit(0);
        vm.stopPrank();
    }

    function testDepositWhenInactive() public {
        vm.prank(strategy.owner());
        strategy.setActive(false);

        vm.startPrank(vault);
        underlying.approve(address(strategy), 1000e6);
        vm.expectRevert(AaveV3SupplyStrategy.NotActive.selector);
        strategy.deposit(1000e6);
        vm.stopPrank();
    }

    function testDepositOnlyVault() public {
        vm.startPrank(user1);
        underlying.approve(address(strategy), 1000e6);
        vm.expectRevert(AaveV3SupplyStrategy.OnlyVault.selector);
        strategy.deposit(1000e6);
        vm.stopPrank();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // WITHDRAW TESTS
    // ═══════════════════════════════════════════════════════════════════════

    function testWithdraw() public {
        uint256 depositAmount = 10000e6;
        
        vm.startPrank(vault);
        underlying.approve(address(strategy), depositAmount);
        uint256 shares = strategy.deposit(depositAmount);

        uint256 balanceBefore = underlying.balanceOf(vault);
        uint256 withdrawn = strategy.withdraw(shares);

        assertEq(withdrawn, depositAmount);
        assertEq(strategy.totalShares(), 0);
        assertEq(strategy.shares(vault), 0);
        assertEq(underlying.balanceOf(vault) - balanceBefore, withdrawn);
        vm.stopPrank();
    }

    function testWithdrawPartial() public {
        uint256 depositAmount = 10000e6;
        
        vm.startPrank(vault);
        underlying.approve(address(strategy), depositAmount);
        uint256 shares = strategy.deposit(depositAmount);

        uint256 withdrawShares = shares / 2;
        uint256 withdrawn = strategy.withdraw(withdrawShares);

        assertApproxEqAbs(withdrawn, depositAmount / 2, 1);
        assertEq(strategy.shares(vault), shares - withdrawShares);
        vm.stopPrank();
    }

    function testWithdrawInsufficientShares() public {
        vm.startPrank(vault);
        vm.expectRevert(AaveV3SupplyStrategy.InsufficientShares.selector);
        strategy.withdraw(1000);
        vm.stopPrank();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HARVEST TESTS
    // ═══════════════════════════════════════════════════════════════════════

    function testHarvest() public {
        vm.startPrank(vault);
        underlying.approve(address(strategy), 10000e6);
        strategy.deposit(10000e6);
        vm.stopPrank();

        uint256 harvested = strategy.harvest();
        assertGt(harvested, 0);
        assertGt(rewardToken.balanceOf(vault), 0);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // VIEW FUNCTION TESTS
    // ═══════════════════════════════════════════════════════════════════════

    function testCurrentAPY() public {
        uint256 apy = strategy.currentAPY();
        assertGt(apy, 0);
        assertLt(apy, 10000); // Less than 100%
    }

    function testTotalAssets() public {
        assertEq(strategy.totalAssets(), 0);

        vm.startPrank(vault);
        underlying.approve(address(strategy), 10000e6);
        strategy.deposit(10000e6);
        vm.stopPrank();

        assertEq(strategy.totalAssets(), aToken.balanceOf(address(strategy)));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // ADMIN FUNCTION TESTS
    // ═══════════════════════════════════════════════════════════════════════

    function testEmergencyWithdraw() public {
        vm.startPrank(vault);
        underlying.approve(address(strategy), 10000e6);
        strategy.deposit(10000e6);
        vm.stopPrank();

        address owner = strategy.owner();
        uint256 balanceBefore = underlying.balanceOf(owner);

        vm.prank(owner);
        strategy.emergencyWithdraw();

        assertFalse(strategy.active());
        assertEq(strategy.totalShares(), 0);
        assertGt(underlying.balanceOf(owner), balanceBefore);
    }

    function testSetEMode() public {
        vm.prank(strategy.owner());
        strategy.setEMode(1);
        assertEq(strategy.eModeCategoryId(), 1);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FUZZ TESTS
    // ═══════════════════════════════════════════════════════════════════════

    function testFuzzDeposit(uint256 amount) public {
        amount = bound(amount, 1e6, 1000000e6);
        underlying.mint(vault, amount);

        vm.startPrank(vault);
        underlying.approve(address(strategy), amount);
        uint256 shares = strategy.deposit(amount);

        assertGt(shares, 0);
        assertEq(strategy.totalDeposited(), amount);
        vm.stopPrank();
    }

    function testFuzzWithdraw(uint256 depositAmount, uint256 withdrawPct) public {
        depositAmount = bound(depositAmount, 1000e6, 1000000e6);
        withdrawPct = bound(withdrawPct, 1, 100);

        underlying.mint(vault, depositAmount);

        vm.startPrank(vault);
        underlying.approve(address(strategy), depositAmount);
        uint256 shares = strategy.deposit(depositAmount);

        uint256 withdrawShares = (shares * withdrawPct) / 100;
        uint256 withdrawn = strategy.withdraw(withdrawShares);

        assertGt(withdrawn, 0);
        vm.stopPrank();
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// AAVE V3 LEVERAGE STRATEGY TESTS
// ═══════════════════════════════════════════════════════════════════════════════

contract AaveV3LeverageStrategyTest is Test {
    MockERC20 public underlying;
    MockAToken public aToken;
    MockERC20 public debtToken;
    MockAavePool public pool;
    MockRewardsController public rewards;
    MockPriceOracle public oracle;
    AaveV3LeverageStrategy public strategy;

    address vault = address(0x1000);
    uint256 targetLeverage = 20000; // 2x

    function setUp() public {
        underlying = new MockERC20("USDC", "USDC", 6);
        pool = new MockAavePool();
        aToken = new MockAToken(address(pool), address(underlying));
        debtToken = new MockERC20("dUSDC", "dUSDC", 6);
        rewards = new MockRewardsController();
        oracle = new MockPriceOracle();

        pool.setAToken(address(underlying), address(aToken));
        pool.setDebtToken(address(underlying), address(debtToken));

        strategy = new AaveV3LeverageStrategy(
            vault, address(pool), address(aToken), address(rewards), address(oracle), targetLeverage
        );

        underlying.mint(vault, 1000000e6);
        underlying.mint(address(pool), 10000000e6);
    }

    function testLeverageDeployment() public {
        assertEq(strategy.targetLeverageRatio(), targetLeverage);
        assertEq(strategy.minHealthFactor(), 1.05e18);
        assertTrue(strategy.active());
    }

    function testLeverageDeposit() public {
        uint256 depositAmount = 10000e6;

        vm.startPrank(vault);
        underlying.approve(address(strategy), depositAmount);
        uint256 shares = strategy.deposit(depositAmount);

        assertGt(shares, 0);
        assertGt(aToken.balanceOf(address(strategy)), depositAmount);
        vm.stopPrank();
    }

    function testSetTargetLeverageRatio() public {
        vm.prank(strategy.owner());
        strategy.setTargetLeverageRatio(30000);
        assertEq(strategy.targetLeverageRatio(), 30000);
    }

    function testInvalidLeverageRatio() public {
        vm.startPrank(strategy.owner());
        
        vm.expectRevert(AaveV3LeverageStrategy.InvalidLeverageRatio.selector);
        new AaveV3LeverageStrategy(vault, address(pool), address(aToken), address(rewards), address(oracle), 5000);
        
        vm.stopPrank();
    }
}
